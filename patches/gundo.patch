diff --git a/tests/bundled/lh-vim-lib/autoload/lh/UT.vim b/tests/bundled/lh-vim-lib/autoload/lh/UT.vim
deleted file mode 120000
index 7bff7e0..0000000
--- a/tests/bundled/lh-vim-lib/autoload/lh/UT.vim
+++ /dev/null
@@ -1 +0,0 @@
-../../../../bundled/ut/autoload/lh/UT.vim
\ No newline at end of file
diff --git a/tests/bundled/lh-vim-lib/autoload/lh/UT.vim b/tests/bundled/lh-vim-lib/autoload/lh/UT.vim
new file mode 100644
index 0000000..4e7bacf
--- /dev/null
+++ b/tests/bundled/lh-vim-lib/autoload/lh/UT.vim
@@ -0,0 +1,442 @@
+"=============================================================================
+" $Id: UT.vim 193 2010-05-17 23:10:03Z luc.hermitte $
+" File:         autoload/lh/UT.vim                                {{{1
+" Author:       Luc Hermitte <EMAIL:hermitte {at} free {dot} fr>
+"               <URL:http://code.google.com/p/lh-vim/>
+" Version:      0.0.3
+" Created:      11th Feb 2009
+" Last Update:  $Date: 2010-05-17 19:10:03 -0400 (Mon, 17 May 2010) $
+"------------------------------------------------------------------------
+" Description:  Yet Another Unit Testing Framework for Vim 
+" 
+"------------------------------------------------------------------------
+" Installation: 
+" 	Drop this file into {rtp}/autoload/lh/
+" History:      
+" 	Strongly inspired by Tom Link's tAssert plugin: all its functions are
+" 	compatible with this framework.
+"
+" Features:
+" - Assertion failures are reported in the quickfix window
+" - Assertion syntax is simple, check Tom Link's suite, it's the same
+" - Supports banged :Assert! to stop processing a given test on failed
+"   assertions
+" - All the s:Test* functions of a suite are executed (almost) independently
+"   (i.e., a critical :Assert! failure will stop the Test of the function, and
+"   lh#UT will proceed to the next s:Test function
+" - Lightweight and simple to use: there is only one command defined, all the
+"   other definitions are kept in an autoload plugin.
+" - A suite == a file
+" - Several s:TestXxx() per suite
+" - +optional s:Setup(), s:Teardown()
+" - Supports :Comment's ; :Comment takes an expression to evaluate
+" - s:LocalFunctions(), s:variables, and l:variables are supported
+" - Takes advantage of BuildToolsWrapper's :Copen command if installed
+" - Count successful tests (and not successful assertions)
+" - Short-cuts to run the Unit Tests associated to a given vim script
+"   Relies on: Let-Modeline/local_vimrc/Project to set g:UTfiles (space
+"   separated list of glob-able paths), and on lh-vim-lib#path
+" - Command to exclude, or specify the tests to play => UTPlay, UTIgnore
+" - Option g:UT_print_test to display, on assertion failure, the current test
+"   name with the assertion failed.
+"
+" TODO:         
+" - Always execute s:Teardown() -- move its call to a :finally bloc
+" - Test in UTF-8 (because of <SNR>_ injection)
+" - test under windows (where paths have spaces, etc)
+" - What about s:/SNR pollution ? The tmpfile is reused, and there is no
+"   guaranty a script will clean its own place
+" - add &efm for viml errors like the one produced by :Assert 0 + [0]
+"   and take into account the offset introduced by lines injected at the top of
+"   the file
+" - simplify s:errors functions
+" - merge with Tom Link tAssert plugin? (the UI is quite different)
+" - :AssertEquals that shows the name of both expressions and their values as
+"   well -- a correct distinction of both parameters will be tricky with
+"   regexes ; using functions will loose either the name, or the value in case
+"   of local/script variables use ; we need macros /à la C/...
+" - Support Embedded comments like for instance: 
+"   Assert 1 == 1 " 1 must value 1
+" - Ways to test buffers produced
+" }}}1
+"=============================================================================
+
+let s:cpo_save=&cpo
+set cpo&vim
+"------------------------------------------------------------------------
+
+" ## Functions {{{1
+"------------------------------------------------------------------------
+" # Debug {{{2
+function! lh#UT#verbose(level)
+  let s:verbose = a:level
+endfunction
+
+function! s:Verbose(expr, ...)
+  let lvl = a:0>0 ? a:1 : 1
+  if exists('s:verbose') && s:verbose >= lvl
+    echomsg a:expr
+  endif
+endfunction
+
+function! lh#UT#debug(expr)
+  return eval(a:expr)
+endfunction
+
+"------------------------------------------------------------------------
+" # Internal functions {{{2
+"------------------------------------------------------------------------
+ 
+" Sourcing a script doesn't imply a new entry with its name in :scriptnames
+" As a consequence, the easiest thing to do is to reuse the same file over and
+" over in a given vim session.
+" This approach should be fine as long as there are less than 26 VimL testing vim
+" sessions opened simultaneously.
+let s:tempfile = tempname()
+
+"------------------------------------------------------------------------
+" s:errors
+let s:errors = {
+      \ 'qf'                    : [],
+      \ 'crt_suite'             : {},
+      \ 'nb_asserts'            : 0,
+      \ 'nb_successful_asserts' : 0,
+      \ 'nb_success'            : 0,
+      \ 'suites'                : []
+      \ }
+
+function! s:errors.clear() dict
+  let self.qf                    = []
+  let self.nb_asserts            = 0
+  let self.nb_successful_asserts = 0
+  let self.nb_success            = 0
+  let self.nb_tests              = 0
+  let self.suites                = []
+  let self.crt_suite             = {}
+endfunction
+
+function! s:errors.display() dict
+  let g:errors = self.qf
+  cexpr self.qf
+
+  " Open the quickfix window
+  if exists(':Copen')
+    " Defined in lh-BTW, make the windows as big as the number of errors, not
+    " opened if there is no error
+    Copen
+  else
+    copen
+  endif
+endfunction
+
+function! s:errors.set_current_SNR(SNR)
+  let self.crt_suite.snr = a:SNR
+endfunction
+
+function! s:errors.get_current_SNR()
+  return self.crt_suite.snr
+endfunction
+
+function! s:errors.add(FILE, LINE, message) dict
+  let msg = a:FILE.':'.a:LINE.':'
+  if lh#option#get('UT_print_test', 0, 'g') && has_key(s:errors, 'crt_test')
+    let msg .= '['. s:errors.crt_test.name .'] '
+  endif
+  let msg.= a:message
+  call add(self.qf, msg)
+endfunction
+
+function! s:errors.add_test(test_name) dict
+  call self.add_test(a:test_name)
+endfunction
+
+function! s:errors.set_test_failed() dict
+  if has_key(self, 'crt_test') 
+    let self.crt_test.failed = 1
+  endif
+endfunction
+
+"------------------------------------------------------------------------
+" Tests wrapper functions
+
+function! s:RunOneTest(file) dict
+  try
+    let s:errors.crt_test = self
+    if has_key(s:errors.crt_suite, 'setup')
+      let F = function(s:errors.get_current_SNR().'Setup')
+      call F()
+    endif
+    let F = function(s:errors.get_current_SNR(). self.name)
+    call F()
+    if has_key(s:errors.crt_suite, 'teardown')
+      let F = function(s:errors.get_current_SNR().'Teardown')
+      call F()
+    endif
+  catch /Assert: abort/
+    call s:errors.add(a:file, 
+          \ matchstr(v:exception, '.*(\zs\d\+\ze)'),
+          \ 'Test <'. self.name .'> execution aborted on critical assertion failure')
+  catch /.*/
+    let throwpoint = substitute(v:throwpoint, escape(s:tempfile, '.\'), a:file, 'g')
+    let msg = throwpoint . ': '.v:exception
+    call s:errors.add(a:file, 0, msg)
+  finally
+    unlet s:errors.crt_test
+  endtry
+endfunction
+
+function! s:AddTest(test_name) dict
+  let test = {
+        \ 'name'   : a:test_name,
+        \ 'run'    : function('s:RunOneTest'),
+        \ 'failed' : 0
+        \ }
+  call add(self.tests, test)
+endfunction
+
+"------------------------------------------------------------------------
+" Suites wrapper functions
+
+function! s:ConcludeSuite() dict
+  call s:errors.add(self.file,0,  'SUITE<'. self.name.'> '. s:errors.nb_success .'/'. s:errors.nb_tests . ' tests successfully executed.')
+  " call add(s:errors.qf, 'SUITE<'. self.name.'> '. s:rrors.nb_success .'/'. s:errors.nb_tests . ' tests successfully executed.')
+endfunction
+
+function! s:PlayTests(...) dict
+  call s:Verbose('Execute tests: '.join(a:000, ', '))
+  call filter(self.tests, 'index(a:000, v:val.name) >= 0')
+  call s:Verbose('Keeping tests: '.join(self.tests, ', '))
+endfunction
+
+function! s:IgnoreTests(...) dict
+  call s:Verbose('Ignoring tests: '.join(a:000, ', '))
+  call filter(self.tests, 'index(a:000, v:val.name) < 0')
+  call s:Verbose('Keeping tests: '.join(self.tests, ', '))
+endfunction
+
+function! s:errors.new_suite(file) dict
+  let suite = {
+        \ 'scriptname'      : s:tempfile,
+        \ 'file'            : a:file,
+        \ 'tests'           : [],
+        \ 'snr'             : '',
+        \ 'add_test'        : function('s:AddTest'),
+        \ 'conclude'        : function('s:ConcludeSuite'),
+        \ 'play'            : function('s:PlayTests'),
+        \ 'ignore'          : function('s:IgnoreTests'),
+        \ 'nb_tests_failed' : 0
+        \ }
+  call add(self.suites, suite)
+  let self.crt_suite = suite
+  return suite
+endfunction
+
+function! s:errors.set_suite(suite_name) dict
+  let a = s:Decode(a:suite_name)
+  call s:Verbose('SUITE <- '. a.expr, 1)
+  call s:Verbose('SUITE NAME: '. a:suite_name, 2)
+  " call self.add(a.file, a.line, 'SUITE <'. a.expr .'>')
+  call self.add(a.file,0, 'SUITE <'. a.expr .'>')
+  let self.crt_suite.name = a.expr
+  " let self.crt_suite.file = a.file
+endfunction
+
+"------------------------------------------------------------------------
+function! s:Decode(expression)
+  let filename = s:errors.crt_suite.file
+  let expr = a:expression
+  let line = matchstr(expr, '^\d\+')
+  " echo filename.':'.line
+  let expr = strpart(expr, strlen(line)+1)
+  let res = { 'file':filename, 'line':line, 'expr':expr}
+  call s:Verbose('decode:'. (res.file) .':'. (res.line) .':'. (res.expr), 2)
+  return res
+endfunction
+
+function! lh#UT#callback_decode(expression)
+  return s:Decode(a:expression)
+endfunction
+
+"------------------------------------------------------------------------
+let s:k_commands = '\%(Assert\|UTSuite\|Comment\)'
+let s:k_local_evaluate = [
+      \ 'command! -bang -nargs=1 Assert '.
+      \ 'let s:a = lh#UT#callback_decode(<q-args>) |'.
+      \ 'let s:ok = !empty(eval(s:a.expr))  |'.
+      \ 'exe "UTAssert<bang> ".s:ok." ".(<f-args>)|'
+      \]
+let s:k_getSNR   = [
+      \ 'function! s:getSNR()',
+      \ '  if !exists("s:SNR")',
+      \ '    let s:SNR=matchstr(expand("<sfile>"), "<SNR>\\d\\+_\\zegetSNR$")',
+      \ '  endif',
+      \ '  return s:SNR', 
+      \ 'endfunction',
+      \ 'call lh#UT#callback_set_SNR(s:getSNR())',
+      \ ''
+      \ ]
+
+function! s:PrepareFile(file)
+  if !filereadable(a:file)
+    call s:errors.add('-', 0, a:file . " can not be read")
+    return 
+  endif
+  let file = escape(a:file, ' \')
+
+  let lines = readfile(a:file)
+  let need_to_know_SNR = 0
+  let suite = s:errors.new_suite(a:file)
+
+  let no = 0
+  let last_line = len(lines)
+  while no < last_line
+    if lines[no] =~ '^\s*'.s:k_commands.'\>'
+      let lines[no] = substitute(lines[no], '^\s*'.s:k_commands.'!\= \zs', (no+1).' ', '')
+
+    elseif lines[no] =~ '^\s*function!\=\s\+s:Test'
+      let test_name = matchstr(lines[no], '^\s*function!\=\s\+s:\zsTest\S\{-}\ze(')
+      call suite.add_test(test_name)
+    elseif lines[no] =~ '^\s*function!\=\s\+s:Teardown'
+      let suite.teardown = 1
+    elseif lines[no] =~ '^\s*function!\=\s\+s:Setup'
+      let suite.setup = 1
+    endif
+    if lines[no] =~ '^\s*function!\=\s\+s:'
+      let need_to_know_SNR = 1
+    endif
+    let no += 1
+  endwhile
+
+  " Inject s:getSNR() in the script if there is a s:Function in the Test script
+  if need_to_know_SNR
+    call extend(lines, s:k_getSNR, 0)
+    let last_line += len(s:k_getSNR)
+  endif
+
+  " Inject local evualation of expressions in the script
+  " => takes care of s:variables, s:Functions(), and l:variables
+  call extend(lines, s:k_local_evaluate, 0)
+
+  call writefile(lines, suite.scriptname)
+  let g:lines=lines
+endfunction
+
+function! s:RunOneFile(file)
+  try 
+    call s:PrepareFile(a:file)
+    exe 'source '.s:tempfile
+
+    let s:errors.nb_tests = len(s:errors.crt_suite.tests)
+    if !empty(s:errors.crt_suite.tests)
+      call s:Verbose('Executing tests: '.join(s:errors.crt_suite.tests, ', '))
+      for test in s:errors.crt_suite.tests
+        call test.run(a:file)
+        let s:errors.nb_success += 1 - test.failed
+      endfor
+    endif
+
+  catch /Assert: abort/
+    call s:errors.add(a:file, 
+          \ matchstr(v:exception, '.*(\zs\d\+\ze)'),
+          \ 'Suite <'. s:errors.crt_suite .'> execution aborted on critical assertion failure')
+  catch /.*/
+    let throwpoint = substitute(v:throwpoint, escape(s:tempfile, '.\'), a:file, 'g')
+    let msg = throwpoint . ': '.v:exception
+    call s:errors.add(a:file, 0, msg)
+  finally
+    call s:errors.crt_suite.conclude()
+    " Never! the name must not be used by other Vim sessions
+    " call delete(s:tempfile)
+  endtry
+endfunction
+
+"------------------------------------------------------------------------
+function! s:StripResultAndDecode(expr)
+  " Function needed because of an odd degenerescence of vim: commands
+  " eventually loose their '\'
+  return s:Decode(matchstr(a:expr, '^\d\+\s\+\zs.*')) 
+endfunction
+
+function! s:GetResult(expr)
+  " Function needed because of an odd degenerescence of vim: commands
+  " eventually loose their '\'
+  return matchstr(a:expr, '^\d\+\ze\s\+.*') 
+endfunction
+
+function! s:DefineCommands()
+  " NB: variables are already interpreted, make it a function
+  " command! -nargs=1 Assert call s:Assert(<q-args>)
+  command! -bang -nargs=1 UTAssert 
+        \ let s:a = s:StripResultAndDecode(<q-args>)                |
+        \ let s:ok = s:GetResult(<q-args>)                         |
+        \ let s:errors.nb_asserts += 1                                            |
+        \ if ! s:ok                                                               |
+        \    call s:errors.set_test_failed()                                      |
+        \    call s:errors.add(s:a.file, s:a.line, 'assertion failed: '.s:a.expr) |
+        \    if '<bang>' == '!'                                                   |
+        \       throw "Assert: abort (".s:a.line.")"                              |
+        \    endif                                                                |
+        \ else                                                                    |
+        \    let s:errors.nb_successful_asserts += 1                              |
+        \ endif
+
+  command! -nargs=1 Comment
+        \ let s:a = s:Decode(<q-args>)                                            |
+        \ call s:errors.add(s:a.file, s:a.line, eval(s:a.expr))
+  command! -nargs=1 UTSuite call s:errors.set_suite(<q-args>)
+
+  command! -nargs=+ UTPlay   call s:errors.crt_suite.play(<f-args>)
+  command! -nargs=+ UTIgnore call s:errors.crt_suite.ignore(<f-args>)
+endfunction
+
+function! s:UnDefineCommands()
+  silent! delcommand Assert
+  silent! delcommand UTAssert
+  silent! command! -nargs=* UTSuite :echoerr "Use :UTRun and not :source on this script"<bar>finish
+  silent! delcommand UTPlay
+  silent! delcommand UTIgnore
+endfunction
+"------------------------------------------------------------------------
+" # callbacks {{{2
+function! lh#UT#callback_set_SNR(SNR)
+  call s:errors.set_current_SNR(a:SNR)
+endfunction
+
+" # Main function {{{2
+function! lh#UT#run(bang,...)
+  " 1- clear the errors table
+  let must_keep = a:bang == "!"
+  if ! must_keep
+    call s:errors.clear()
+  endif
+
+  try 
+    " 2- define commands
+    call s:DefineCommands()
+
+    " 3- run every test
+    let rtp = '.,'.&rtp
+    let files = []
+    for file in a:000
+      let lFile = lh#path#glob_as_list(rtp, file)
+      if len(lFile) > 0
+	call add(files, lFile[0])
+      endif
+    endfor
+
+    for file in files
+      call s:RunOneFile(file)
+    endfor
+  finally
+    call s:UnDefineCommands()
+    call s:errors.display()
+  endtry
+
+  " 3- Open the quickfix
+endfunction
+
+"------------------------------------------------------------------------
+let &cpo=s:cpo_save
+"=============================================================================
+" vim600: set fdm=marker:
+" VIM: let g:UTfiles='tests/lh/UT*.vim'
diff --git a/tests/vim_test/autoload/lh b/tests/vim_test/autoload/lh
deleted file mode 120000
index 011ec62..0000000
--- a/tests/vim_test/autoload/lh
+++ /dev/null
@@ -1 +0,0 @@
-../../bundled/lh-vim-lib/autoload/lh
\ No newline at end of file
diff --git a/tests/vim_test/ftplugin/vim b/tests/vim_test/ftplugin/vim
deleted file mode 120000
index b3b92a6..0000000
--- a/tests/vim_test/ftplugin/vim
+++ /dev/null
@@ -1 +0,0 @@
-../../bundled/ut/ftplugin/vim
\ No newline at end of file
diff --git a/tests/vim_test/macros/menu-map.vim b/tests/vim_test/macros/menu-map.vim
deleted file mode 120000
index bc67ef8..0000000
--- a/tests/vim_test/macros/menu-map.vim
+++ /dev/null
@@ -1 +0,0 @@
-../../bundled/lh-vim-lib/macros/menu-map.vim
\ No newline at end of file
diff --git a/tests/vim_test/macros/menu-map.vim b/tests/vim_test/macros/menu-map.vim
new file mode 100644
index 0000000..6bae67b
--- /dev/null
+++ b/tests/vim_test/macros/menu-map.vim
@@ -0,0 +1,83 @@
+"===========================================================================
+" $Id: menu-map.vim 246 2010-09-19 22:40:58Z luc.hermitte $
+" File:		macros/menu-map.vim
+" Author:	Luc Hermitte <EMAIL:hermitte {at} free {dot} fr>
+" 		<URL:http://code.google.com/p/lh-vim/>
+"
+" Purpose:	Define functions to build mappings and menus at the same time
+"
+" Version:	2.2.1
+" Last Update:  $Date: 2010-09-19 18:40:58 -0400 (Sun, 19 Sep 2010) $ (02nd Dec 2006)
+"
+" Last Changes: {{{
+" 	Version 2.0.0:
+" 		Moved to vim7, 
+" 		Functions moved to {rtp}/autoload/
+" 	Version 1.6.2: 
+" 		(*) Silent mappings and menus
+" 	Version 1.6. : 
+" 		(*) Uses has('gui_running') instead of has('gui') to check if
+" 		we can generate the menu.
+" 	Version 1.5. : 
+" 		(*) visual mappings launched from select-mode don't end with
+" 		    text still selected -- applied to :VCalls
+" 	Version 1.4. : 
+" 		(*) address obfuscated for spammers
+" 		(*) support the local option 
+" 		    b:want_buffermenu_or_global_disable if we don't want
+" 		    buffermenu to be used systematically.
+" 		    0 -> buffer menu not used
+" 		    1 -> buffer menu used
+" 		    2 -> the VimL developper will use a global disable.
+" 		    cf.:   tex-maps.vim:: s:SimpleMenu()
+" 		       and texmenus.vim
+" 	Version 1.3. :
+"		(*) add continuation lines support ; cf 'cpoptions'
+" 	Version 1.2. :
+" 		(*) Code folded.
+" 		(*) Take advantage of buffermenu.vim if present for local
+" 		    menus.
+" 		(*) If non gui is available, the menus won't be defined
+" 	Version 1.1. :
+"               (*) Bug corrected : 
+"                   vnore(map\|menu) does not imply v+n(map\|menu) any more
+" }}}
+"
+" Inspired By:	A function from Benji Fisher
+"
+" TODO:		(*) no menu if no gui.
+"
+"===========================================================================
+
+if exists("g:loaded_menu_map") | finish | endif
+let g:loaded_menu_map = 1  
+
+"" line continuation used here ??
+let s:cpo_save = &cpo
+set cpo&vim
+
+"=========================================================================
+" Commands {{{
+command! -nargs=+ -bang      MAP      map<bang> <args>
+command! -nargs=+           IMAP     imap       <args>
+command! -nargs=+           NMAP     nmap       <args>
+command! -nargs=+           CMAP     cmap       <args>
+command! -nargs=+           VMAP     vmap       <args>
+command! -nargs=+           AMAP
+      \       call lh#menu#map_all('amap', <f-args>)
+
+command! -nargs=+ -bang  NOREMAP  noremap<bang> <args>
+command! -nargs=+       INOREMAP inoremap       <args>
+command! -nargs=+       NNOREMAP nnoremap       <args>
+command! -nargs=+       CNOREMAP cnoremap       <args>
+command! -nargs=+       VNOREMAP vnoremap       <args>
+command! -nargs=+       ANOREMAP
+      \       call lh#menu#map_all('anoremap', <f-args>)
+" }}}
+
+" End !
+let &cpo = s:cpo_save
+finish
+
+"=========================================================================
+" vim600: set fdm=marker:
diff --git a/tests/vim_test/plugin/UT.vim b/tests/vim_test/plugin/UT.vim
deleted file mode 120000
index 6f6a46f..0000000
--- a/tests/vim_test/plugin/UT.vim
+++ /dev/null
@@ -1 +0,0 @@
-../../bundled/ut/plugin/UT.vim
\ No newline at end of file
diff --git a/tests/vim_test/plugin/UT.vim b/tests/vim_test/plugin/UT.vim
new file mode 100644
index 0000000..34fb7bf
--- /dev/null
+++ b/tests/vim_test/plugin/UT.vim
@@ -0,0 +1,48 @@
+"=============================================================================
+" $Id: UT.vim 193 2010-05-17 23:10:03Z luc.hermitte $
+" File:		plugin/UT.vim                                        {{{1
+" Author:	Luc Hermitte <EMAIL:hermitte {at} free {dot} fr>
+"		<URL:http://code.google.com/p/lh-vim/>
+let s:k_version = 003
+" Version:	0.0.3
+" Created:	11th Feb 2009
+" Last Update:	$Date: 2010-05-17 19:10:03 -0400 (Mon, 17 May 2010) $
+"------------------------------------------------------------------------
+" Description:	Yet Another Unit Testing Framework for Vim 
+" 
+"------------------------------------------------------------------------
+" Installation:	
+" 	Drop the file into {rtp}/plugin/lh/
+" History:	
+" 	Strongly inspired by Tom Link's tAssert
+" TODO:		«missing features»
+" }}}1
+"=============================================================================
+
+" Avoid global reinclusion {{{1
+if &cp || (exists("g:loaded_UT") && !exists('g:force_reload_UT'))
+  finish
+endif
+let g:loaded_UT = s:k_version
+let s:cpo_save=&cpo
+set cpo&vim
+" Avoid global reinclusion }}}1
+"------------------------------------------------------------------------
+" Commands and Mappings {{{1
+
+" Real commands (used to call UT files)
+"command! UTRun {filenames}
+command! -bang -nargs=+ -complete=file UTRun :call lh#UT#run("<bang>",<f-args>)
+
+" Fake commands (used in UT files)
+"command UTSuite {expression} [#{comments}]
+command! -nargs=* UTSuite :echoerr "Use :UTRun and not :source on this script"<bar>finish
+"command Assert {expression} [#{comments}]
+
+
+" Commands and Mappings }}}1
+"------------------------------------------------------------------------
+let &cpo=s:cpo_save
+"=============================================================================
+" vim600: set fdm=marker:
+" VIM: let g:UTfiles='tests/lh/UT*.vim'
diff --git a/tests/vim_test/plugin/gundo.vim b/tests/vim_test/plugin/gundo.vim
deleted file mode 120000
index 577c454..0000000
--- a/tests/vim_test/plugin/gundo.vim
+++ /dev/null
@@ -1 +0,0 @@
-../../../plugin/gundo.vim
\ No newline at end of file
diff --git a/tests/vim_test/plugin/gundo.vim b/tests/vim_test/plugin/gundo.vim
new file mode 100644
index 0000000..29f1e9b
--- /dev/null
+++ b/tests/vim_test/plugin/gundo.vim
@@ -0,0 +1,969 @@
+" ============================================================================
+" File:        gundo.vim
+" Description: vim global plugin to visualize your undo tree
+" Maintainer:  Steve Losh <steve@stevelosh.com>
+" License:     GPLv2+ -- look it up.
+" Notes:       Much of this code was thiefed from Mercurial, and the rest was
+"              heavily inspired by scratch.vim and histwin.vim.
+"
+" ============================================================================
+
+
+"{{{ Init
+
+if !exists('g:gundo_debug') && (exists('g:gundo_disable') || exists('loaded_gundo') || &cp)"{{{
+    finish
+endif
+let loaded_gundo = 1"}}}
+
+if v:version < '703'"{{{
+    function! s:GundoDidNotLoad()
+        echohl WarningMsg|echomsg "Gundo unavailable: requires Vim 7.3+"|echohl None
+    endfunction
+    command! -nargs=0 GundoToggle call s:GundoDidNotLoad()
+    finish
+endif"}}}
+
+if has('python')"{{{
+    let s:has_supported_python = 1
+
+python << ENDPYTHON
+import sys
+import vim
+if sys.version_info[:2] < (2, 4):
+    vim.command('let s:has_supported_python = 0')
+ENDPYTHON
+else
+    let s:has_supported_python = 0
+endif
+
+if !s:has_supported_python
+    function! s:GundoDidNotLoad()
+        echohl WarningMsg|echomsg "Gundo requires Vim to be compiled with Python 2.4+"|echohl None
+    endfunction
+    command! -nargs=0 GundoToggle call s:GundoDidNotLoad()
+    finish
+endif"}}}
+
+if !exists('g:gundo_width')"{{{
+    let g:gundo_width = 45
+endif"}}}
+if !exists('g:gundo_preview_height')"{{{
+    let g:gundo_preview_height = 15
+endif"}}}
+if !exists('g:gundo_preview_bottom')"{{{
+    let g:gundo_preview_bottom = 0
+endif"}}}
+if !exists('g:gundo_right')"{{{
+    let g:gundo_right = 0
+endif"}}}
+if !exists('g:gundo_help')"{{{
+    let g:gundo_help = 1
+endif"}}}
+if !exists("g:gundo_map_move_older")"{{{
+    let g:gundo_map_move_older = 'j'
+endif"}}}
+if !exists("g:gundo_map_move_newer")"{{{
+    let g:gundo_map_move_newer = 'k'
+endif"}}}
+if !exists("g:gundo_close_on_revert")"{{{
+    let g:gundo_close_on_revert = 0
+endif"}}}
+
+"}}}
+
+"{{{ Mercurial's graphlog code
+python << ENDPYTHON
+def asciiedges(seen, rev, parents):
+    """adds edge info to changelog DAG walk suitable for ascii()"""
+    if rev not in seen:
+        seen.append(rev)
+    nodeidx = seen.index(rev)
+
+    knownparents = []
+    newparents = []
+    for parent in parents:
+        if parent in seen:
+            knownparents.append(parent)
+        else:
+            newparents.append(parent)
+
+    ncols = len(seen)
+    seen[nodeidx:nodeidx + 1] = newparents
+    edges = [(nodeidx, seen.index(p)) for p in knownparents]
+
+    if len(newparents) > 0:
+        edges.append((nodeidx, nodeidx))
+    if len(newparents) > 1:
+        edges.append((nodeidx, nodeidx + 1))
+
+    nmorecols = len(seen) - ncols
+    return nodeidx, edges, ncols, nmorecols
+
+def get_nodeline_edges_tail(
+        node_index, p_node_index, n_columns, n_columns_diff, p_diff, fix_tail):
+    if fix_tail and n_columns_diff == p_diff and n_columns_diff != 0:
+        # Still going in the same non-vertical direction.
+        if n_columns_diff == -1:
+            start = max(node_index + 1, p_node_index)
+            tail = ["|", " "] * (start - node_index - 1)
+            tail.extend(["/", " "] * (n_columns - start))
+            return tail
+        else:
+            return ["\\", " "] * (n_columns - node_index - 1)
+    else:
+        return ["|", " "] * (n_columns - node_index - 1)
+
+def draw_edges(edges, nodeline, interline):
+    for (start, end) in edges:
+        if start == end + 1:
+            interline[2 * end + 1] = "/"
+        elif start == end - 1:
+            interline[2 * start + 1] = "\\"
+        elif start == end:
+            interline[2 * start] = "|"
+        else:
+            nodeline[2 * end] = "+"
+            if start > end:
+                (start, end) = (end, start)
+            for i in range(2 * start + 1, 2 * end):
+                if nodeline[i] != "+":
+                    nodeline[i] = "-"
+
+def fix_long_right_edges(edges):
+    for (i, (start, end)) in enumerate(edges):
+        if end > start:
+            edges[i] = (start, end + 1)
+
+def ascii(buf, state, type, char, text, coldata):
+    """prints an ASCII graph of the DAG
+
+    takes the following arguments (one call per node in the graph):
+
+      - Somewhere to keep the needed state in (init to asciistate())
+      - Column of the current node in the set of ongoing edges.
+      - Type indicator of node data == ASCIIDATA.
+      - Payload: (char, lines):
+        - Character to use as node's symbol.
+        - List of lines to display as the node's text.
+      - Edges; a list of (col, next_col) indicating the edges between
+        the current node and its parents.
+      - Number of columns (ongoing edges) in the current revision.
+      - The difference between the number of columns (ongoing edges)
+        in the next revision and the number of columns (ongoing edges)
+        in the current revision. That is: -1 means one column removed;
+        0 means no columns added or removed; 1 means one column added.
+    """
+
+    idx, edges, ncols, coldiff = coldata
+    assert -2 < coldiff < 2
+    if coldiff == -1:
+        # Transform
+        #
+        #     | | |        | | |
+        #     o | |  into  o---+
+        #     |X /         |/ /
+        #     | |          | |
+        fix_long_right_edges(edges)
+
+    # add_padding_line says whether to rewrite
+    #
+    #     | | | |        | | | |
+    #     | o---+  into  | o---+
+    #     |  / /         |   | |  # <--- padding line
+    #     o | |          |  / /
+    #                    o | |
+    add_padding_line = (len(text) > 2 and coldiff == -1 and
+                        [x for (x, y) in edges if x + 1 < y])
+
+    # fix_nodeline_tail says whether to rewrite
+    #
+    #     | | o | |        | | o | |
+    #     | | |/ /         | | |/ /
+    #     | o | |    into  | o / /   # <--- fixed nodeline tail
+    #     | |/ /           | |/ /
+    #     o | |            o | |
+    fix_nodeline_tail = len(text) <= 2 and not add_padding_line
+
+    # nodeline is the line containing the node character (typically o)
+    nodeline = ["|", " "] * idx
+    nodeline.extend([char, " "])
+
+    nodeline.extend(
+        get_nodeline_edges_tail(idx, state[1], ncols, coldiff,
+                                state[0], fix_nodeline_tail))
+
+    # shift_interline is the line containing the non-vertical
+    # edges between this entry and the next
+    shift_interline = ["|", " "] * idx
+    if coldiff == -1:
+        n_spaces = 1
+        edge_ch = "/"
+    elif coldiff == 0:
+        n_spaces = 2
+        edge_ch = "|"
+    else:
+        n_spaces = 3
+        edge_ch = "\\"
+    shift_interline.extend(n_spaces * [" "])
+    shift_interline.extend([edge_ch, " "] * (ncols - idx - 1))
+
+    # draw edges from the current node to its parents
+    draw_edges(edges, nodeline, shift_interline)
+
+    # lines is the list of all graph lines to print
+    lines = [nodeline]
+    if add_padding_line:
+        lines.append(get_padding_line(idx, ncols, edges))
+    lines.append(shift_interline)
+
+    # make sure that there are as many graph lines as there are
+    # log strings
+    while len(text) < len(lines):
+        text.append("")
+    if len(lines) < len(text):
+        extra_interline = ["|", " "] * (ncols + coldiff)
+        while len(lines) < len(text):
+            lines.append(extra_interline)
+
+    # print lines
+    indentation_level = max(ncols, ncols + coldiff)
+    for (line, logstr) in zip(lines, text):
+        ln = "%-*s %s" % (2 * indentation_level, "".join(line), logstr)
+        buf.write(ln.rstrip() + '\n')
+
+    # ... and start over
+    state[0] = coldiff
+    state[1] = idx
+
+def generate(dag, edgefn, current):
+    seen, state = [], [0, 0]
+    buf = Buffer()
+    for node, parents in list(dag):
+        if node.time:
+            age_label = age(int(node.time))
+        else:
+            age_label = 'Original'
+        line = '[%s] %s' % (node.n, age_label)
+        if node.n == current:
+            char = '@'
+        else:
+            char = 'o'
+        ascii(buf, state, 'C', char, [line], edgefn(seen, node, parents))
+    return buf.b
+ENDPYTHON
+"}}}
+
+"{{{ Mercurial age function
+python << ENDPYTHON
+import time
+
+agescales = [("year", 3600 * 24 * 365),
+             ("month", 3600 * 24 * 30),
+             ("week", 3600 * 24 * 7),
+             ("day", 3600 * 24),
+             ("hour", 3600),
+             ("minute", 60),
+             ("second", 1)]
+
+def age(ts):
+    '''turn a timestamp into an age string.'''
+
+    def plural(t, c):
+        if c == 1:
+            return t
+        return t + "s"
+    def fmt(t, c):
+        return "%d %s" % (c, plural(t, c))
+
+    now = time.time()
+    then = ts
+    if then > now:
+        return 'in the future'
+
+    delta = max(1, int(now - then))
+    if delta > agescales[0][1] * 2:
+        return time.strftime('%Y-%m-%d', time.gmtime(float(ts)))
+
+    for t, s in agescales:
+        n = delta // s
+        if n >= 2 or s == 1:
+            return '%s ago' % fmt(t, n)
+ENDPYTHON
+"}}}
+
+"{{{ Python Vim utility functions
+python << ENDPYTHON
+import vim
+
+normal = lambda s: vim.command('normal %s' % s)
+
+MISSING_BUFFER = "Cannot find Gundo's target buffer (%s)"
+MISSING_WINDOW = "Cannot find window (%s) for Gundo's target buffer (%s)"
+
+def _check_sanity():
+    '''Check to make sure we're not crazy.
+
+    Does the following things:
+
+        * Make sure the target buffer still exists.
+    '''
+    b = int(vim.eval('g:gundo_target_n'))
+
+    if not vim.eval('bufloaded(%d)' % b):
+        vim.command('echo "%s"' % (MISSING_BUFFER % b))
+        return False
+
+    w = int(vim.eval('bufwinnr(%d)' % b))
+    if w == -1:
+        vim.command('echo "%s"' % (MISSING_WINDOW % (w, b)))
+        return False
+
+    return True
+
+def _goto_window_for_buffer(b):
+    w = int(vim.eval('bufwinnr(%d)' % int(b)))
+    vim.command('%dwincmd w' % w)
+
+def _goto_window_for_buffer_name(bn):
+    b = vim.eval('bufnr("%s")' % bn)
+    return _goto_window_for_buffer(b)
+
+def _undo_to(n):
+    n = int(n)
+    if n == 0:
+        vim.command('silent earlier %s' % (int(vim.eval('&undolevels')) + 1))
+    else:
+        vim.command('silent undo %d' % n)
+
+
+INLINE_HELP = '''\
+" Gundo for %s (%d)
+" j/k  - move between undo states
+" p    - preview diff of selected and current states
+" <cr> - revert to selected state
+
+'''
+ENDPYTHON
+"}}}
+
+"{{{ Python undo tree data structures and functions
+python << ENDPYTHON
+import itertools
+
+class Buffer(object):
+    def __init__(self):
+        self.b = ''
+
+    def write(self, s):
+        self.b += s
+
+class Node(object):
+    def __init__(self, n, parent, time, curhead):
+        self.n = int(n)
+        self.parent = parent
+        self.children = []
+        self.curhead = curhead
+        self.time = time
+
+def _make_nodes(alts, nodes, parent=None):
+    p = parent
+
+    for alt in alts:
+        curhead = 'curhead' in alt
+        node = Node(n=alt['seq'], parent=p, time=alt['time'], curhead=curhead)
+        nodes.append(node)
+        if alt.get('alt'):
+            _make_nodes(alt['alt'], nodes, p)
+        p = node
+
+def make_nodes():
+    ut = vim.eval('undotree()')
+    entries = ut['entries']
+
+    root = Node(0, None, False, 0)
+    nodes = []
+    _make_nodes(entries, nodes, root)
+    nodes.append(root)
+    nmap = dict((node.n, node) for node in nodes)
+    return nodes, nmap
+
+def changenr(nodes):
+    _curhead_l = list(itertools.dropwhile(lambda n: not n.curhead, nodes))
+    if _curhead_l:
+        current = _curhead_l[0].parent.n
+    else:
+        current = int(vim.eval('changenr()'))
+    return current
+ENDPYTHON
+"}}}
+
+"{{{ Gundo utility functions
+
+function! s:GundoGetTargetState()"{{{
+    let target_line = matchstr(getline("."), '\v\[[0-9]+\]')
+    return matchstr(target_line, '\v[0-9]+')
+endfunction"}}}
+
+function! s:GundoGoToWindowForBufferName(name)"{{{
+    if bufwinnr(bufnr(a:name)) != -1
+        exe bufwinnr(bufnr(a:name)) . "wincmd w"
+        return 1
+    else
+        return 0
+    endif
+endfunction"}}}
+
+function! s:GundoIsVisible()"{{{
+    if bufwinnr(bufnr("__Gundo__")) != -1 || bufwinnr(bufnr("__Gundo_Preview__")) != -1
+        return 1
+    else
+        return 0
+    endif
+endfunction"}}}
+
+function! s:GundoInlineHelpLength()"{{{
+    if g:gundo_help
+        return 6
+    else
+        return 0
+    endif
+endfunction"}}}
+
+"}}}
+
+"{{{ Gundo buffer settings
+
+function! s:GundoMapGraph()"{{{
+    exec 'nnoremap <script> <silent> <buffer> ' . g:gundo_map_move_older . " :call <sid>GundoMove(1)<CR>"
+    exec 'nnoremap <script> <silent> <buffer> ' . g:gundo_map_move_newer . " :call <sid>GundoMove(-1)<CR>"
+    nnoremap <script> <silent> <buffer> <CR>          :call <sid>GundoRevert()<CR>
+    nnoremap <script> <silent> <buffer> o             :call <sid>GundoRevert()<CR>
+    nnoremap <script> <silent> <buffer> <down>        :call <sid>GundoMove(1)<CR>
+    nnoremap <script> <silent> <buffer> <up>          :call <sid>GundoMove(-1)<CR>
+    nnoremap <script> <silent> <buffer> gg            gg:call <sid>GundoMove(1)<CR>
+    nnoremap <script> <silent> <buffer> P             :call <sid>GundoPlayTo()<CR>
+    nnoremap <script> <silent> <buffer> p             :call <sid>GundoRenderChangePreview()<CR>
+    nnoremap <script> <silent> <buffer> q             :call <sid>GundoClose()<CR>
+    cabbrev  <script> <silent> <buffer> q             call <sid>GundoClose()
+    cabbrev  <script> <silent> <buffer> quit          call <sid>GundoClose()
+    nnoremap <script> <silent> <buffer> <2-LeftMouse> :call <sid>GundoMouseDoubleClick()<CR>
+endfunction"}}}
+
+function! s:GundoMapPreview()"{{{
+    nnoremap <script> <silent> <buffer> q     :call <sid>GundoClose()<CR>
+    cabbrev  <script> <silent> <buffer> q     call <sid>GundoClose()
+    cabbrev  <script> <silent> <buffer> quit  call <sid>GundoClose()
+endfunction"}}}
+
+function! s:GundoSettingsGraph()"{{{
+    setlocal buftype=nofile
+    setlocal bufhidden=hide
+    setlocal noswapfile
+    setlocal nobuflisted
+    setlocal nomodifiable
+    setlocal filetype=gundo
+    setlocal nolist
+    setlocal nonumber
+    setlocal norelativenumber
+    setlocal nowrap
+    call s:GundoSyntaxGraph()
+    call s:GundoMapGraph()
+endfunction"}}}
+
+function! s:GundoSettingsPreview()"{{{
+    setlocal buftype=nofile
+    setlocal bufhidden=hide
+    setlocal noswapfile
+    setlocal nobuflisted
+    setlocal nomodifiable
+    setlocal filetype=diff
+    setlocal nonumber
+    setlocal norelativenumber
+    setlocal nowrap
+    setlocal foldlevel=20
+    setlocal foldmethod=diff
+    call s:GundoMapPreview()
+endfunction"}}}
+
+function! s:GundoSyntaxGraph()"{{{
+    let b:current_syntax = 'gundo'
+
+    syn match GundoCurrentLocation '@'
+    syn match GundoHelp '\v^".*$'
+    syn match GundoNumberField '\v\[[0-9]+\]'
+    syn match GundoNumber '\v[0-9]+' contained containedin=GundoNumberField
+
+    hi def link GundoCurrentLocation Keyword
+    hi def link GundoHelp Comment
+    hi def link GundoNumberField Comment
+    hi def link GundoNumber Identifier
+endfunction"}}}
+
+"}}}
+
+"{{{ Gundo buffer/window management
+
+function! s:GundoResizeBuffers(backto)"{{{
+    call s:GundoGoToWindowForBufferName('__Gundo__')
+    exe "vertical resize " . g:gundo_width
+
+    call s:GundoGoToWindowForBufferName('__Gundo_Preview__')
+    exe "resize " . g:gundo_preview_height
+
+    exe a:backto . "wincmd w"
+endfunction"}}}
+
+function! s:GundoOpenGraph()"{{{
+    let existing_gundo_buffer = bufnr("__Gundo__")
+
+    if existing_gundo_buffer == -1
+        call s:GundoGoToWindowForBufferName('__Gundo_Preview__')
+        exe "new __Gundo__"
+        if g:gundo_preview_bottom
+            if g:gundo_right
+                wincmd L
+            else
+                wincmd H
+            endif
+        endif
+        call s:GundoResizeBuffers(winnr())
+    else
+        let existing_gundo_window = bufwinnr(existing_gundo_buffer)
+
+        if existing_gundo_window != -1
+            if winnr() != existing_gundo_window
+                exe existing_gundo_window . "wincmd w"
+            endif
+        else
+            call s:GundoGoToWindowForBufferName('__Gundo_Preview__')
+            if g:gundo_preview_bottom
+                if g:gundo_right
+                    exe "botright vsplit +buffer" . existing_gundo_buffer
+                else
+                    exe "topleft vsplit +buffer" . existing_gundo_buffer
+                endif
+            else
+                exe "split +buffer" . existing_gundo_buffer
+            endif
+            call s:GundoResizeBuffers(winnr())
+        endif
+    endif
+endfunction"}}}
+
+function! s:GundoOpenPreview()"{{{
+    let existing_preview_buffer = bufnr("__Gundo_Preview__")
+
+    if existing_preview_buffer == -1
+        if g:gundo_preview_bottom
+            exe "botright new __Gundo_Preview__"
+        else
+            if g:gundo_right
+                exe "botright vnew __Gundo_Preview__"
+            else
+                exe "topleft vnew __Gundo_Preview__"
+            endif
+        endif
+    else
+        let existing_preview_window = bufwinnr(existing_preview_buffer)
+
+        if existing_preview_window != -1
+            if winnr() != existing_preview_window
+                exe existing_preview_window . "wincmd w"
+            endif
+        else
+            if g:gundo_preview_bottom
+                exe "botright split +buffer" . existing_preview_buffer
+            else
+                if g:gundo_right
+                    exe "botright vsplit +buffer" . existing_preview_buffer
+                else
+                    exe "topleft vsplit +buffer" . existing_preview_buffer
+                endif
+            endif
+        endif
+    endif
+endfunction"}}}
+
+function! s:GundoClose()"{{{
+    if s:GundoGoToWindowForBufferName('__Gundo__')
+        quit
+    endif
+
+    if s:GundoGoToWindowForBufferName('__Gundo_Preview__')
+        quit
+    endif
+
+    exe bufwinnr(g:gundo_target_n) . "wincmd w"
+endfunction"}}}
+
+function! s:GundoOpen()"{{{
+    " Save `splitbelow` value and set it to default to avoid problems with
+    " positioning new windows.
+    let saved_splitbelow = &splitbelow
+    let &splitbelow = 0
+
+    call s:GundoOpenPreview()
+    exe bufwinnr(g:gundo_target_n) . "wincmd w"
+
+    call s:GundoRenderGraph()
+    call s:GundoRenderPreview()
+
+    " Restore `splitbelow` value.
+    let &splitbelow = saved_splitbelow
+endfunction"}}}
+
+function! s:GundoToggle()"{{{
+    if s:GundoIsVisible()
+        call s:GundoClose()
+    else
+        let g:gundo_target_n = bufnr('')
+        let g:gundo_target_f = @%
+        call s:GundoOpen()
+    endif
+endfunction"}}}
+
+"}}}
+
+"{{{ Gundo mouse handling
+
+function! s:GundoMouseDoubleClick()"{{{
+    let start_line = getline('.')
+
+    if stridx(start_line, '[') == -1
+        return
+    else
+        call s:GundoRevert()
+    endif
+endfunction"}}}
+
+"}}}
+
+"{{{ Gundo movement
+
+function! s:GundoMove(direction) range"{{{
+    let start_line = getline('.')
+    if v:count1 == 0
+        let move_count = 1
+    else
+        let move_count = v:count1
+    endif
+    let distance = 2 * move_count
+
+    " If we're in between two nodes we move by one less to get back on track.
+    if stridx(start_line, '[') == -1
+        let distance = distance - 1
+    endif
+
+    let target_n = line('.') + (distance * a:direction)
+
+    " Bound the movement to the graph.
+    if target_n <= s:GundoInlineHelpLength() - 1
+        call cursor(s:GundoInlineHelpLength(), 0)
+    else
+        call cursor(target_n, 0)
+    endif
+
+    let line = getline('.')
+
+    " Move to the node, whether it's an @ or an o
+    let idx1 = stridx(line, '@')
+    let idx2 = stridx(line, 'o')
+    if idx1 != -1
+        call cursor(0, idx1 + 1)
+    else
+        call cursor(0, idx2 + 1)
+    endif
+
+    call s:GundoRenderPreview()
+endfunction"}}}
+
+"}}}
+
+"{{{ Gundo rendering
+
+"{{{ Rendering utility functions
+python << ENDPYTHON
+import difflib
+
+def _fmt_time(t):
+    return time.strftime('%Y-%m-%d %I:%M:%S %p', time.localtime(float(t)))
+
+def _output_preview_text(lines):
+    _goto_window_for_buffer_name('__Gundo_Preview__')
+    vim.command('setlocal modifiable')
+    vim.current.buffer[:] = lines
+    vim.command('setlocal nomodifiable')
+
+def _generate_preview_diff(current, node_before, node_after):
+    _goto_window_for_buffer(vim.eval('g:gundo_target_n'))
+
+    if not node_after.n:    # we're at the original file
+        before_lines = []
+
+        _undo_to(0)
+        after_lines = vim.current.buffer[:]
+
+        before_name = 'n/a'
+        before_time = ''
+        after_name = 'Original'
+        after_time = ''
+    elif not node_before.n: # we're at a pseudo-root state
+        _undo_to(0)
+        before_lines = vim.current.buffer[:]
+
+        _undo_to(node_after.n)
+        after_lines = vim.current.buffer[:]
+
+        before_name = 'Original'
+        before_time = ''
+        after_name = node_after.n
+        after_time = _fmt_time(node_after.time)
+    else:
+        _undo_to(node_before.n)
+        before_lines = vim.current.buffer[:]
+
+        _undo_to(node_after.n)
+        after_lines = vim.current.buffer[:]
+
+        before_name = node_before.n
+        before_time = _fmt_time(node_before.time)
+        after_name = node_after.n
+        after_time = _fmt_time(node_after.time)
+
+    _undo_to(current)
+
+    return list(difflib.unified_diff(before_lines, after_lines,
+                                     before_name, after_name,
+                                     before_time, after_time))
+
+def _generate_change_preview_diff(current, node_before, node_after):
+    _goto_window_for_buffer(vim.eval('g:gundo_target_n'))
+
+    _undo_to(node_before.n)
+    before_lines = vim.current.buffer[:]
+
+    _undo_to(node_after.n)
+    after_lines = vim.current.buffer[:]
+
+    before_name = node_before.n or 'Original'
+    before_time = node_before.time and _fmt_time(node_before.time) or ''
+    after_name = node_after.n or 'Original'
+    after_time = node_after.time and _fmt_time(node_after.time) or ''
+
+    _undo_to(current)
+
+    return list(difflib.unified_diff(before_lines, after_lines,
+                                     before_name, after_name,
+                                     before_time, after_time))
+ENDPYTHON
+"}}}
+
+function! s:GundoRenderGraph()"{{{
+python << ENDPYTHON
+def GundoRenderGraph():
+    if not _check_sanity():
+        return
+
+    nodes, nmap = make_nodes()
+
+    for node in nodes:
+        node.children = [n for n in nodes if n.parent == node]
+
+    def walk_nodes(nodes):
+        for node in nodes:
+            if node.parent:
+                yield (node, [node.parent])
+            else:
+                yield (node, [])
+
+    dag = sorted(nodes, key=lambda n: int(n.n), reverse=True)
+    current = changenr(nodes)
+
+    result = generate(walk_nodes(dag), asciiedges, current).rstrip().splitlines()
+    result = [' ' + l for l in result]
+
+    target = (vim.eval('g:gundo_target_f'), int(vim.eval('g:gundo_target_n')))
+
+    if int(vim.eval('g:gundo_help')):
+        header = (INLINE_HELP % target).splitlines()
+    else:
+        header = []
+
+    vim.command('call s:GundoOpenGraph()')
+    vim.command('setlocal modifiable')
+    vim.current.buffer[:] = (header + result)
+    vim.command('setlocal nomodifiable')
+
+    i = 1
+    for line in result:
+        try:
+            line.split('[')[0].index('@')
+            i += 1
+            break
+        except ValueError:
+            pass
+        i += 1
+    vim.command('%d' % (i+len(header)-1))
+
+GundoRenderGraph()
+ENDPYTHON
+endfunction"}}}
+
+function! s:GundoRenderPreview()"{{{
+python << ENDPYTHON
+def GundoRenderPreview():
+    if not _check_sanity():
+        return
+
+    target_state = vim.eval('s:GundoGetTargetState()')
+
+    # Check that there's an undo state. There may not be if we're talking about
+    # a buffer with no changes yet.
+    if target_state == None:
+        _goto_window_for_buffer_name('__Gundo__')
+        return
+    else:
+        target_state = int(target_state)
+
+    _goto_window_for_buffer(vim.eval('g:gundo_target_n'))
+
+    nodes, nmap = make_nodes()
+    current = changenr(nodes)
+
+    node_after = nmap[target_state]
+    node_before = node_after.parent
+
+    vim.command('call s:GundoOpenPreview()')
+    _output_preview_text(_generate_preview_diff(current, node_before, node_after))
+
+    _goto_window_for_buffer_name('__Gundo__')
+
+GundoRenderPreview()
+ENDPYTHON
+endfunction"}}}
+
+function! s:GundoRenderChangePreview()"{{{
+python << ENDPYTHON
+def GundoRenderChangePreview():
+    if not _check_sanity():
+        return
+
+    target_state = vim.eval('s:GundoGetTargetState()')
+
+    # Check that there's an undo state. There may not be if we're talking about
+    # a buffer with no changes yet.
+    if target_state == None:
+        _goto_window_for_buffer_name('__Gundo__')
+        return
+    else:
+        target_state = int(target_state)
+
+    _goto_window_for_buffer(vim.eval('g:gundo_target_n'))
+
+    nodes, nmap = make_nodes()
+    current = changenr(nodes)
+
+    node_after = nmap[target_state]
+    node_before = nmap[current]
+
+    vim.command('call s:GundoOpenPreview()')
+    _output_preview_text(_generate_change_preview_diff(current, node_before, node_after))
+
+    _goto_window_for_buffer_name('__Gundo__')
+
+GundoRenderChangePreview()
+ENDPYTHON
+endfunction"}}}
+
+"}}}
+
+"{{{ Gundo undo/redo
+
+function! s:GundoRevert()"{{{
+python << ENDPYTHON
+def GundoRevert():
+    if not _check_sanity():
+        return
+
+    target_n = int(vim.eval('s:GundoGetTargetState()'))
+    back = vim.eval('g:gundo_target_n')
+
+    _goto_window_for_buffer(back)
+    _undo_to(target_n)
+
+    vim.command('GundoRenderGraph')
+    _goto_window_for_buffer(back)
+
+    if int(vim.eval('g:gundo_close_on_revert')):
+        vim.command('GundoToggle')
+
+GundoRevert()
+ENDPYTHON
+endfunction"}}}
+
+function! s:GundoPlayTo()"{{{
+python << ENDPYTHON
+def GundoPlayTo():
+    if not _check_sanity():
+        return
+
+    target_n = int(vim.eval('s:GundoGetTargetState()'))
+    back = int(vim.eval('g:gundo_target_n'))
+
+    vim.command('echo "%s"' % back)
+
+    _goto_window_for_buffer(back)
+    normal('zR')
+
+    nodes, nmap = make_nodes()
+
+    start = nmap[changenr(nodes)]
+    end = nmap[target_n]
+
+    def _walk_branch(origin, dest):
+        rev = origin.n < dest.n
+
+        nodes = []
+        if origin.n > dest.n:
+            current, final = origin, dest
+        else:
+            current, final = dest, origin
+
+        while current.n >= final.n:
+            if current.n == final.n:
+                break
+            nodes.append(current)
+            current = current.parent
+        else:
+            return None
+        nodes.append(current)
+
+        return reversed(nodes) if rev else nodes
+
+    branch = _walk_branch(start, end)
+
+    if not branch:
+        vim.command('unsilent echo "No path to that node from here!"')
+        return
+
+    for node in branch:
+        _undo_to(node.n)
+        vim.command('GundoRenderGraph')
+        normal('zz')
+        _goto_window_for_buffer(back)
+        vim.command('redraw')
+        vim.command('sleep 60m')
+
+GundoPlayTo()
+ENDPYTHON
+endfunction"}}}
+
+"}}}
+
+"{{{ Misc
+command! -nargs=0 GundoToggle call s:GundoToggle()
+command! -nargs=0 GundoRenderGraph call s:GundoRenderGraph()
+autocmd BufNewFile __Gundo__ call s:GundoSettingsGraph()
+autocmd BufNewFile __Gundo_Preview__ call s:GundoSettingsPreview()
+"}}}
diff --git a/tests/vim_test/plugin/let.vim b/tests/vim_test/plugin/let.vim
deleted file mode 120000
index ebba541..0000000
--- a/tests/vim_test/plugin/let.vim
+++ /dev/null
@@ -1 +0,0 @@
-../../bundled/lh-vim-lib/plugin/let.vim
\ No newline at end of file
diff --git a/tests/vim_test/plugin/let.vim b/tests/vim_test/plugin/let.vim
new file mode 100644
index 0000000..ad98f43
--- /dev/null
+++ b/tests/vim_test/plugin/let.vim
@@ -0,0 +1,54 @@
+"=============================================================================
+" $Id: let.vim 239 2010-06-01 00:48:43Z luc.hermitte $
+" File:         plugin/let.vim                                    {{{1
+" Author:       Luc Hermitte <EMAIL:hermitte {at} free {dot} fr>
+"		<URL:http://code.google.com/p/lh-vim/>
+" Version:      2.2.1
+" Created:      31st May 2010
+" Last Update:  $Date: 2010-05-31 20:48:43 -0400 (Mon, 31 May 2010) $
+"------------------------------------------------------------------------
+" Description:
+"       Defines a command :LetIfUndef that sets a variable if undefined
+" 
+"------------------------------------------------------------------------
+" Installation:
+"       Drop this file into {rtp}/plugin
+"       Requires Vim7+
+" History:      
+" 	v2.2.1: first version of this command into lh-vim-lib
+" TODO: 
+" }}}1
+"=============================================================================
+
+" Avoid global reinclusion {{{1
+let s:k_version = 221
+if &cp || (exists("g:loaded_let")
+      \ && (g:loaded_let >= s:k_version)
+      \ && !exists('g:force_reload_let'))
+  finish
+endif
+let g:loaded_let = s:k_version
+let s:cpo_save=&cpo
+set cpo&vim
+" Avoid global reinclusion }}}1
+"------------------------------------------------------------------------
+" Commands and Mappings {{{1
+command! -nargs=+ LetIfUndef call s:LetIfUndef(<f-args>)
+" Commands and Mappings }}}1
+"------------------------------------------------------------------------
+" Functions {{{1
+" Note: most functions are best placed into
+" autoload/«your-initials»/«let».vim
+" Keep here only the functions are are required when the plugin is loaded,
+" like functions that help building a vim-menu for this plugin.
+function! s:LetIfUndef(var, value)
+  if !exists(a:var)
+    let {a:var} = eval(a:value)
+  endif
+endfunction
+
+" Functions }}}1
+"------------------------------------------------------------------------
+let &cpo=s:cpo_save
+"=============================================================================
+" vim600: set fdm=marker:
diff --git a/tests/vim_test/plugin/lhvl.vim b/tests/vim_test/plugin/lhvl.vim
deleted file mode 120000
index abb1ccb..0000000
--- a/tests/vim_test/plugin/lhvl.vim
+++ /dev/null
@@ -1 +0,0 @@
-../../bundled/lh-vim-lib/plugin/lhvl.vim
\ No newline at end of file
diff --git a/tests/vim_test/plugin/lhvl.vim b/tests/vim_test/plugin/lhvl.vim
new file mode 100644
index 0000000..367e25d
--- /dev/null
+++ b/tests/vim_test/plugin/lhvl.vim
@@ -0,0 +1,45 @@
+"=============================================================================
+" $Id: lhvl.vim 245 2010-09-19 22:40:10Z luc.hermitte $
+" File:		plugin/lhvl.vim                                   {{{1
+" Author:	Luc Hermitte <EMAIL:hermitte {at} free {dot} fr>
+"		<URL:http://code.google.com/p/lh-vim/>
+" Version:	2.2.1
+" Created:	27th Apr 2010
+" Last Update:	$Date: 2010-09-19 18:40:10 -0400 (Sun, 19 Sep 2010) $
+"------------------------------------------------------------------------
+" Description:	
+"       Non-function resources from lh-vim-lib
+" 
+"------------------------------------------------------------------------
+" Installation:	
+"       Drop the file into {rtp}/plugin
+" History:	
+"       v2.2.1  first version
+" TODO:		«missing features»
+" }}}1
+"=============================================================================
+
+" Avoid global reinclusion {{{1
+let s:k_version = 221
+if &cp || (exists("g:loaded_lhvl")
+      \ && (g:loaded_lhvl >= s:k_version)
+      \ && !exists('g:force_reload_lhvl'))
+  finish
+endif
+let g:loaded_lhvl = s:k_version
+let s:cpo_save=&cpo
+set cpo&vim
+" Avoid global reinclusion }}}1
+"------------------------------------------------------------------------
+" Commands and Mappings {{{1
+" Moved from lh-cpp
+command! PopSearch :call histdel('search', -1)| let @/=histget('search',-1)
+
+" Commands and Mappings }}}1
+"------------------------------------------------------------------------
+" Functions {{{1
+" Functions }}}1
+"------------------------------------------------------------------------
+let &cpo=s:cpo_save
+"=============================================================================
+" vim600: set fdm=marker:
diff --git a/tests/vim_test/plugin/ui-functions.vim b/tests/vim_test/plugin/ui-functions.vim
deleted file mode 120000
index 00e69b8..0000000
--- a/tests/vim_test/plugin/ui-functions.vim
+++ /dev/null
@@ -1 +0,0 @@
-../../bundled/lh-vim-lib/plugin/ui-functions.vim
\ No newline at end of file
diff --git a/tests/vim_test/plugin/ui-functions.vim b/tests/vim_test/plugin/ui-functions.vim
new file mode 100644
index 0000000..8f7c3d9
--- /dev/null
+++ b/tests/vim_test/plugin/ui-functions.vim
@@ -0,0 +1,480 @@
+"=============================================================================
+" File:         plugin/ui-functions.vim                                  {{{1
+" Author:       Luc Hermitte <EMAIL:hermitte {at} free {dot} fr>
+"               <URL:http://code.google.com/p/lh-vim/>
+" URL: http://hermitte.free.fr/vim/ressources/vimfiles/plugin/ui-functions.vim
+" 
+" Version:      2.2.1
+" Created:      18th nov 2002
+" Last Update:  28th Nov 2007
+"------------------------------------------------------------------------
+" Description:  Functions for the interaction with a User Interface.
+"               The UI can be graphical or textual.
+"               At first, this was designed to ease the syntax of
+"               mu-template's templates.
+"
+" Option:       {{{2
+"       {[bg]:ui_type} 
+"               = "g\%[ui]", 
+"               = "t\%[ext]" ; the call must not be |:silent|
+"               = "f\%[te]"
+" }}}2
+"------------------------------------------------------------------------
+" Installation: Drop this into one of your {rtp}/plugin/ directories.
+" History:      {{{2
+"    v0.01 Initial Version
+"    v0.02
+"       (*) Code "factorisations" 
+"       (*) Help on <F1> enhanced.
+"       (*) Small changes regarding the parameter accepted
+"       (*) Function SWITCH
+"    v0.03
+"       (*) Small bug fix with INPUT()
+"    v0.04
+"       (*) New function: WHICH()
+"    v0.05
+"       (*) In vim7e, inputdialog() returns a trailing '\n'. INPUT() strips the
+"           NL character.
+"    v0.06
+"       (*) :s/echoerr/throw/ => vim7 only
+"    v2.2.0
+"       (*) menu to switch the ui_type
+" 
+" TODO:         {{{2
+"       (*) Save the hl-User1..9 before using them
+"       (*) Possibility other than &statusline:
+"           echohl User1 |echon "bla"|echohl User2|echon "bli"|echohl None
+"       (*) Wraps too long choices-line (length > term-width)
+"       (*) Add to the documentation: "don't use CTRL-C to abort !!"
+"       (*) Look if I need to support 'wildmode'
+"       (*) 3rd mode: return string for FTE
+"       (*) 4th mode: interaction in a scratch buffer
+"
+" }}}1
+"=============================================================================
+" Avoid reinclusion {{{1
+" 
+if exists("g:loaded_ui_functions") && !exists('g:force_reload_ui_functions')
+  finish 
+endif
+let g:loaded_ui_functions = 1
+let s:cpo_save=&cpo
+set cpo&vim
+" }}}1
+"------------------------------------------------------------------------
+" External functions {{{1
+" Function: IF(var, then, else) {{{2
+function! IF(var,then, else)
+  let o = s:Opt_type() " {{{3
+  if     o =~ 'g\%[ui]\|t\%[ext]' " {{{4
+    return a:var ? a:then : a:else
+  elseif o =~ 'f\%[te]'           " {{{4
+    return s:if_fte(a:var, a:then, a:else)
+  else                    " {{{4
+    throw "UI-Fns::IF(): Unkonwn user-interface style (".o.")"
+  endif
+  " }}}3
+endfunction
+
+" Function: SWITCH(var, case, action [, case, action] [default_action]) {{{2
+function! SWITCH(var, ...)
+  let o = s:Opt_type() " {{{3
+  if     o =~ 'g\%[ui]\|t\%[ext]' " {{{4
+    let explicit_def = ((a:0 % 2) == 1)
+    let default      = explicit_def ? a:{a:0} : ''
+    let i = a:0 - 1 - explicit_def
+    while i > 0
+      if a:var == a:{i}
+        return a:{i+1}
+      endif
+      let i = i - 2
+    endwhile
+    return default
+  elseif o =~ 'f\%[te]'           " {{{4
+    return s:if_fte(a:var, a:then, a:else)
+  else                    " {{{4
+    throw "UI-Fns::SWITCH(): Unkonwn user-interface style (".o.")"
+  endif
+  " }}}3
+endfunction
+
+" Function: CONFIRM(text [, choices [, default [, type]]]) {{{2
+function! CONFIRM(text, ...)
+  " 1- Check parameters {{{3
+  if a:0 > 4 " {{{4
+    throw "UI-Fns::CONFIRM(): too many parameters"
+    return 0
+  endif
+  " build the parameters string {{{4
+  let i = 1
+  while i <= a:0
+    if i == 1 | let params = 'a:{1}'
+    else      | let params = params. ',a:{'.i.'}'
+    endif
+    let i = i + 1
+  endwhile
+  " 2- Choose the correct way to execute according to the option {{{3
+  let o = s:Opt_type()
+  if     o =~ 'g\%[ui]'  " {{{4
+    exe 'return confirm(a:text,'.params.')'
+  elseif o =~ 't\%[ext]' " {{{4
+    if !has('gui_running') && has('dialog_con')
+      exe 'return confirm(a:text,'.params.')'
+    else
+      exe 'return s:confirm_text("none", a:text,'.params.')'
+    endif
+  elseif o =~ 'f\%[te]'  " {{{4
+      exe 'return s:confirm_fte(a:text,'.params.')'
+  else               " {{{4
+    throw "UI-Fns::CONFIRM(): Unkonwn user-interface style (".o.")"
+  endif
+  " }}}3
+endfunction
+
+" Function: INPUT(prompt [, default ]) {{{2
+function! INPUT(prompt, ...)
+  " 1- Check parameters {{{3
+  if a:0 > 4 " {{{4
+    throw "UI-Fns::INPUT(): too many parameters"
+    return 0
+  endif
+  " build the parameters string {{{4
+  let i = 1 | let params = ''
+  while i <= a:0
+    if i == 1 | let params = 'a:{1}'
+    else      | let params = params. ',a:{'.i.'}'
+    endif
+    let i = i + 1
+  endwhile
+  " 2- Choose the correct way to execute according to the option {{{3
+  let o = s:Opt_type()
+  if     o =~ 'g\%[ui]'  " {{{4
+    exe 'return matchstr(inputdialog(a:prompt,'.params.'), ".\\{-}\\ze\\n\\=$")'
+  elseif o =~ 't\%[ext]' " {{{4
+    exe 'return input(a:prompt,'.params.')'
+  elseif o =~ 'f\%[te]'  " {{{4
+      exe 'return s:input_fte(a:prompt,'.params.')'
+  else               " {{{4
+    throw "UI-Fns::INPUT(): Unkonwn user-interface style (".o.")"
+  endif
+  " }}}3
+endfunction
+
+" Function: COMBO(prompt, choice [, ... ]) {{{2
+function! COMBO(prompt, ...)
+  " 1- Check parameters {{{3
+  if a:0 > 4 " {{{4
+    throw "UI-Fns::COMBO(): too many parameters"
+    return 0
+  endif
+  " build the parameters string {{{4
+  let i = 1
+  while i <= a:0
+    if i == 1 | let params = 'a:{1}'
+    else      | let params = params. ',a:{'.i.'}'
+    endif
+    let i = i + 1
+  endwhile
+  " 2- Choose the correct way to execute according to the option {{{3
+  let o = s:Opt_type()
+  if     o =~ 'g\%[ui]'  " {{{4
+    exe 'return confirm(a:prompt,'.params.')'
+  elseif o =~ 't\%[ext]' " {{{4
+    exe 'return s:confirm_text("combo", a:prompt,'.params.')'
+  elseif o =~ 'f\%[te]'  " {{{4
+    exe 'return s:combo_fte(a:prompt,'.params.')'
+  else               " {{{4
+    throw "UI-Fns::COMBO(): Unkonwn user-interface style (".o.")"
+  endif
+  " }}}3
+endfunction
+
+" Function: WHICH(function, prompt, choice [, ... ]) {{{2
+function! WHICH(fn, prompt, ...)
+  " 1- Check parameters {{{3
+  " build the parameters string {{{4
+  let i = 1
+  while i <= a:0
+    if i == 1 | let params = 'a:{1}'
+    else      | let params = params. ',a:{'.i.'}'
+    endif
+    let i = i + 1
+  endwhile
+  " 2- Execute the function {{{3
+  exe 'let which = '.a:fn.'(a:prompt,'.params.')'
+  if     0 >= which | return ''
+  elseif 1 == which
+    return substitute(matchstr(a:{1}, '^.\{-}\ze\%(\n\|$\)'), '&', '', 'g')
+  else
+    return substitute(
+          \ matchstr(a:{1}, '^\%(.\{-}\n\)\{'.(which-1).'}\zs.\{-}\ze\%(\n\|$\)')
+          \ , '&', '', 'g')
+  endif
+  " }}}3
+endfunction
+
+" Function: CHECK(prompt, choice [, ... ]) {{{2
+function! CHECK(prompt, ...)
+  " 1- Check parameters {{{3
+  if a:0 > 4 " {{{4
+    throw "UI-Fns::CHECK(): too many parameters"
+    return 0
+  endif
+  " build the parameters string {{{4
+  let i = 1
+  while i <= a:0
+    if i == 1 | let params = 'a:{1}'
+    else      | let params = params. ',a:{'.i.'}'
+    endif
+    let i = i + 1
+  endwhile
+  " 2- Choose the correct way to execute according to the option {{{3
+  let o = s:Opt_type()
+  if     o =~ 'g\%[ui]'  " {{{4
+    exe 'return s:confirm_text("check", a:prompt,'.params.')'
+  elseif o =~ 't\%[ext]' " {{{4
+    exe 'return s:confirm_text("check", a:prompt,'.params.')'
+  elseif o =~ 'f\%[te]'  " {{{4
+      exe 'return s:check_fte(a:prompt,'.params.')'
+  else               " {{{4
+    throw "UI-Fns::CHECK(): Unkonwn user-interface style (".o.")"
+  endif
+  " }}}3
+endfunction
+
+" }}}1
+"------------------------------------------------------------------------
+" Options setting {{{1
+let s:OptionData = {
+      \ "variable": "ui_type",
+      \ "idx_crt_value": 1,
+      \ "values": ['gui', 'text', 'fte'],
+      \ "menu": { "priority": '500.2700', "name": '&Plugin.&LH.&UI type'}
+      \}
+
+call lh#menu#def_toggle_item(s:OptionData)
+
+" }}}1
+"------------------------------------------------------------------------
+" Internal functions {{{1
+function! s:Option(name, default) " {{{2
+  if     exists('b:ui_'.a:name) | return b:ui_{a:name}
+  elseif exists('g:ui_'.a:name) | return g:ui_{a:name}
+  else                          | return a:default
+  endif
+endfunction
+
+
+function! s:Opt_type() " {{{2
+  return s:Option('type', 'gui')
+endfunction
+
+"
+" Function: s:status_line(current, hl [, choices] ) {{{2
+"     a:current: current item
+"     a:hl     : Generic, Warning, Error
+function! s:status_line(current, hl, ...)
+  " Highlightning {{{3
+  if     a:hl == "Generic"  | let hl = '%1*'
+  elseif a:hl == "Warning"  | let hl = '%2*'
+  elseif a:hl == "Error"    | let hl = '%3*'
+  elseif a:hl == "Info"     | let hl = '%4*'
+  elseif a:hl == "Question" | let hl = '%5*'
+  else                      | let hl = '%1*'
+  endif
+  
+  " Build the string {{{3
+  let sl_choices = '' | let i = 1
+  while i <= a:0
+    if i == a:current
+      let sl_choices = sl_choices . ' '. hl . 
+            \ substitute(a:{i}, '&\(.\)', '%6*\1'.hl, '') . '%* '
+    else
+      let sl_choices = sl_choices . ' ' . 
+            \ substitute(a:{i}, '&\(.\)', '%6*\1%*', '') . ' '
+    endif
+    let i = i + 1
+  endwhile
+  " }}}3
+  return sl_choices
+endfunction
+
+
+" Function: s:confirm_text(box, text [, choices [, default [, type]]]) {{{2
+function! s:confirm_text(box, text, ...)
+  let help = "/<esc>/<s-tab>/<tab>/<left>/<right>/<cr>/<F1>"
+  " 1- Retrieve the parameters       {{{3
+  let choices = ((a:0>=1) ? a:1 : '&Ok')
+  let default = ((a:0>=2) ? a:2 : (('check' == a:box) ? 0 : 1))
+  let type    = ((a:0>=3) ? a:3 : 'Generic')
+  if     'none'  == a:box | let prefix = ''
+  elseif 'combo' == a:box | let prefix = '( )_'
+  elseif 'check' == a:box | let prefix = '[ ]_'
+    let help = '/ '.help
+  else                    | let prefix = ''
+  endif
+
+
+  " 2- Retrieve the proposed choices {{{3
+  " Prepare the hot keys
+  let i = 0
+  while i != 26
+    let hotkey_{nr2char(i+65)} = 0
+    let i += 1
+  endwhile
+  let hotkeys = '' | let help_k = '/'
+  " Parse the choices
+  let i = 0
+  while choices != ""
+    let i = i + 1
+    let item    = matchstr(choices, "^.\\{-}\\ze\\(\n\\|$\\)")
+    let choices = matchstr(choices, "\n\\zs.*$")
+    " exe 'anoremenu ]'.a:text.'.'.item.' :let s:choice ='.i.'<cr>'
+    if ('check' == a:box) && (strlen(default)>=i) && (1 == default[i-1])
+      " let choice_{i} = '[X]' . substitute(item, '&', '', '')
+      let choice_{i} = '[X]_' . item
+    else
+      " let choice_{i} = prefix . substitute(item, '&', '', '')
+      let choice_{i} = prefix . item
+    endif
+    if i == 1
+      let list_choices = 'choice_{1}'
+    else
+      let list_choices = list_choices . ',choice_{'.i.'}'
+    endif
+    " Update the hotkey.
+    let key = toupper(matchstr(choice_{i}, '&\zs.\ze'))
+    let hotkey_{key} = i
+    let hotkeys = hotkeys . tolower(key) . toupper(key)
+    let help_k = help_k . tolower(key)
+  endwhile
+  let nb_choices = i
+  if default > nb_choices | let default = nb_choices | endif
+
+  " 3- Run an interactive text menu  {{{3
+  " Note: emenu can not be used through ":exe" {{{4
+  " let wcm = &wcm
+  " set wcm=<tab>
+  " exe ':emenu ]'.a:text.'.'."<tab>"
+  " let &wcm = wcm
+  " 3.1- Preparations for the statusline {{{4
+  " save the statusline
+  let sl = &l:statusline
+  " Color schemes for selected item {{{5
+  :hi User1 term=inverse,bold cterm=inverse,bold ctermfg=Yellow 
+        \ guifg=Black guibg=Yellow
+  :hi User2 term=inverse,bold cterm=inverse,bold ctermfg=LightRed
+        \ guifg=Black guibg=LightRed
+  :hi User3 term=inverse,bold cterm=inverse,bold ctermfg=Red 
+        \ guifg=Black guibg=Red
+  :hi User4 term=inverse,bold cterm=inverse,bold ctermfg=Cyan
+        \ guifg=Black guibg=Cyan
+  :hi User5 term=inverse,bold cterm=inverse,bold ctermfg=LightYellow
+        \ guifg=Black guibg=LightYellow
+  :hi User6 term=inverse,bold cterm=inverse,bold ctermfg=LightGray
+        \ guifg=DarkRed guibg=LightGray
+  " }}}5
+
+  " 3.2- Interactive loop                {{{4
+  let help =  "\r-- Keys available (".help_k.help.")"
+  " item selected at the start
+  let i = ('check' != a:box) ? default : 1
+  let direction = 0 | let toggle = 0
+  while 1
+    if 'combo' == a:box
+      let choice_{i} = substitute(choice_{i}, '^( )', '(*)', '')
+    endif
+    " Colored statusline
+    " Note: unfortunately the 'statusline' is a global option, {{{
+    " not a local one. I the hope that may change, as it does not provokes any
+    " error, I use '&l:statusline'. }}}
+    exe 'let &l:statusline=s:status_line(i, type,'. list_choices .')'
+    if has(':redrawstatus')
+      redrawstatus!
+    else
+      redraw!
+    endif
+    " Echo the current selection
+    echo "\r". a:text.' '.substitute(choice_{i}, '&', '', '')
+    " Wait the user to hit a key
+    let key=getchar()
+    let complType=nr2char(key)
+    " If the key hit matched awaited keys ...
+    if -1 != stridx(" \<tab>\<esc>\<enter>".hotkeys,complType) ||
+          \ (key =~ "\<F1>\\|\<right>\\|\<left>\\|\<s-tab>")
+      if key           == "\<F1>"                       " Help      {{{5
+        redraw!
+        echohl StatusLineNC
+        echo help
+        echohl None
+        let key=getchar()
+        let complType=nr2char(key)
+      endif
+      " TODO: support CTRL-D
+      if     complType == "\<enter>"                    " Validate  {{{5
+        break
+      elseif complType == " "                           " check box {{{5
+        let toggle = 1
+      elseif complType == "\<esc>"                      " Abort     {{{5
+        let i = -1 | break
+      elseif complType == "\<tab>" || key == "\<right>" " Next      {{{5
+        let direction = 1
+      elseif key =~ "\<left>\\|\<s-tab>"                " Previous  {{{5
+        let direction = -1
+      elseif -1 != stridx(hotkeys, complType )          " Hotkeys     {{{5
+        if '' == complType  | continue | endif
+        let direction = hotkey_{toupper(complType)} - i
+        let toggle = 1
+      " else
+      endif
+      " }}}5
+    endif
+    if direction != 0 " {{{5
+      if 'combo' == a:box
+        let choice_{i} = substitute(choice_{i}, '^(\*)', '( )', '')
+      endif
+      let i = i + direction
+      if     i > nb_choices | let i = 1 
+      elseif i == 0         | let i = nb_choices
+      endif
+      let direction = 0
+    endif
+    if toggle == 1    " {{{5
+      if 'check' == a:box
+        let choice_{i} = ((choice_{i}[1] == ' ')? '[X]' : '[ ]') 
+              \ . strpart(choice_{i}, 3)
+      endif
+      let toggle = 0
+    endif
+  endwhile " }}}4
+  " 4- Terminate                     {{{3
+  " Clear screen
+  redraw!
+
+  " Restore statusline
+  let &l:statusline=sl
+  " Return
+  if (i == -1) || ('check' != a:box)
+    return i
+  else
+    let r = '' | let i = 1
+    while i <= nb_choices
+      let r = r . ((choice_{i}[1] == 'X') ? '1' : '0')
+      let i = i + 1
+    endwhile
+    return r
+  endif
+endfunction
+" }}}1
+"------------------------------------------------------------------------
+" Functions that insert fte statements {{{1
+" Function: s:if_fte(var, then, else) {{{2
+" Function: s:confirm_fte(text, [, choices [, default [, type]]]) {{{2
+" Function: s:input_fte(prompt [, default]) {{{2
+" Function: s:combo_fte(prompt, choice [, ...]) {{{2
+" Function: s:check_fte(prompt, choice [, ...]) {{{2
+" }}}1
+"------------------------------------------------------------------------
+let &cpo=s:cpo_save
+"=============================================================================
+" vim600: set fdm=marker:
diff --git a/tests/vim_test/plugin/words_tools.vim b/tests/vim_test/plugin/words_tools.vim
deleted file mode 120000
index 4a47023..0000000
--- a/tests/vim_test/plugin/words_tools.vim
+++ /dev/null
@@ -1 +0,0 @@
-../../bundled/lh-vim-lib/plugin/words_tools.vim
\ No newline at end of file
diff --git a/tests/vim_test/plugin/words_tools.vim b/tests/vim_test/plugin/words_tools.vim
new file mode 100644
index 0000000..4857365
--- /dev/null
+++ b/tests/vim_test/plugin/words_tools.vim
@@ -0,0 +1,104 @@
+" File:		plugin/words_tools.vim
+" Author:	Luc Hermitte <hermitte {at} free {dot} fr>
+" 		<URL:http://code.google.com/p/lh-vim/>
+" URL: http://hermitte.free.fr/vim/ressources/vim_dollar/plugin/words_tools.vim
+"
+" Last Update:	14th nov 2002
+" Purpose:	Define functions better than expand("<cword>")
+"
+" Note:		They are expected to be used in insert mode (thanks to <c-r>
+"               or <c-o>)
+"
+"===========================================================================
+
+" Return the current keyword, uses spaces to delimitate {{{1
+function! GetNearestKeyword()
+  let c = col ('.')-1
+  let ll = getline('.')
+  let ll1 = strpart(ll,0,c)
+  let ll1 = matchstr(ll1,'\k*$')
+  let ll2 = strpart(ll,c,strlen(ll)-c+1)
+  let ll2 = matchstr(ll2,'^\k*')
+  " let ll2 = strpart(ll2,0,match(ll2,'$\|\s'))
+  return ll1.ll2
+endfunction
+
+" Return the current word, uses spaces to delimitate {{{1
+function! GetNearestWord()
+  let c = col ('.')-1
+  let l = line('.')
+  let ll = getline(l)
+  let ll1 = strpart(ll,0,c)
+  let ll1 = matchstr(ll1,'\S*$')
+  let ll2 = strpart(ll,c,strlen(ll)-c+1)
+  let ll2 = strpart(ll2,0,match(ll2,'$\|\s'))
+  ""echo ll1.ll2
+  return ll1.ll2
+endfunction
+
+" Return the word before the cursor, uses spaces to delimitate {{{1
+" Rem : <cword> is the word under or after the cursor
+function! GetCurrentWord()
+  let c = col ('.')-1
+  let l = line('.')
+  let ll = getline(l)
+  let ll1 = strpart(ll,0,c)
+  let ll1 = matchstr(ll1,'\S*$')
+  if strlen(ll1) == 0
+    return ll1
+  else
+    let ll2 = strpart(ll,c,strlen(ll)-c+1)
+    let ll2 = strpart(ll2,0,match(ll2,'$\|\s'))
+    return ll1.ll2
+  endif
+endfunction
+
+" Return the keyword before the cursor, uses \k to delimitate {{{1
+" Rem : <cword> is the word under or after the cursor
+function! GetCurrentKeyword()
+  let c = col ('.')-1
+  let l = line('.')
+  let ll = getline(l)
+  let ll1 = strpart(ll,0,c)
+  let ll1 = matchstr(ll1,'\k*$')
+  if strlen(ll1) == 0
+    return ll1
+  else
+    let ll2 = strpart(ll,c,strlen(ll)-c+1)
+    let ll2 = matchstr(ll2,'^\k*')
+    " let ll2 = strpart(ll2,0,match(ll2,'$\|\s'))
+    return ll1.ll2
+  endif
+endfunction
+
+" Extract the word before the cursor,  {{{1
+" use keyword definitions, skip latter spaces (see "bla word_accepted ")
+function! GetPreviousWord()
+  let lig = getline(line('.'))
+  let lig = strpart(lig,0,col('.')-1)
+  return matchstr(lig, '\<\k*\>\s*$')
+endfunction
+
+" GetLikeCTRL_W() retrieves the characters that i_CTRL-W deletes. {{{1
+" Initial need by Hari Krishna Dara <hari_vim@yahoo.com>
+" Last ver:
+" Pb: "if strlen(w) ==  " --> ") ==  " instead of just "==  ".
+" There still exists a bug regarding the last char of a line. VIM bug ?
+function! GetLikeCTRL_W()
+  let lig = getline(line('.'))
+  let lig = strpart(lig,0,col('.')-1)
+  " treat ending spaces apart.
+  let s = matchstr(lig, '\s*$')
+  let lig = strpart(lig, 0, strlen(lig)-strlen(s))
+  " First case : last characters belong to a "word"
+  let w = matchstr(lig, '\<\k\+\>$')
+  if strlen(w) == 0
+    " otherwise, they belong to a "non word" (without any space)
+    let w = substitute(lig, '.*\(\k\|\s\)', '', 'g')
+  endif
+  return w . s
+endfunction
+
+" }}}1
+"========================================================================
+" vim60: set fdm=marker:
